package com.copperleaf.ballast.examples.navigation

import com.copperleaf.ballast.BallastViewModelConfiguration
import com.copperleaf.ballast.navigation.routing.Destination
import com.copperleaf.ballast.navigation.routing.Route
import com.copperleaf.ballast.navigation.routing.RouteAnnotation
import com.copperleaf.ballast.navigation.routing.RouteMatcher
import com.copperleaf.ballast.navigation.routing.RoutingTable
import com.copperleaf.ballast.navigation.routing.Tag
import com.copperleaf.ballast.navigation.routing.build
import com.copperleaf.ballast.navigation.routing.directions
import com.copperleaf.ballast.navigation.routing.fromEnum
import com.copperleaf.ballast.navigation.routing.intPath
import com.copperleaf.ballast.navigation.routing.optionalStringQuery
import com.copperleaf.ballast.navigation.routing.pathParameter
import com.copperleaf.ballast.navigation.routing.queryParameter
import com.copperleaf.ballast.navigation.vm.RouterBuilder
import com.copperleaf.ballast.navigation.vm.withRouter
import com.copperleaf.ballast.examples.navigation.Route as ExampleRoute

/**
 * Imagine a routing system where classes are annotated with `@Route`, and those classes are used for navigation. There
 * is no inherent connection among those classes, and using KSP, they could be found and aggregated from throughout the
 * codebase. This file represents the code that might be generated by KSP using such a system, with descriptions of each
 * function or classes generated, and how it corresponds to the annotations used in your application code.
 *
 * This is all done to abstract away the URL-based nature of Ballast Navigations' routing system. URLs are a core part
 * of how Ballast Navigation is designed internally but the library is not strictly limited to URLs at the API surface,
 * and it was intentionally designed so that one could write a KSP processor to provide a different API for the same
 * routing library.
 */

// AppScreen
// ---------------------------------------------------------------------------------------------------------------------

/**
 * KSP scans your project code and finds classes annotated with `@Route`. The processor aggregates those routes
 * together and generates and Enum class with the URLs that are needed for Ballast Navigation.
 *
 * Each enum entry's URL is constructed from [ExampleRoute.path] if provided, otherwise the class name. The properties
 * in the class's primary constructor are used to validate the path params, and also append the query string to the full
 * URL.
 *
 * RouteAnnotations can be created using [With], providing a RouteAnnotation class and the parameters to construct an
 * instance of that class.
 */
enum class AppScreenRoute(
    routeFormat: String,
    override val annotations: Set<RouteAnnotation>,
) : Route {
    Home("/Home", annotations = setOf()),
    PostList("/blog?sort={?}", annotations = setOf()),
    PostDetails("/blog/{postId}", annotations = setOf(Tag("Authenticated"))),
    ;

    override val matcher: RouteMatcher = RouteMatcher.create(routeFormat)
}

/**
 * This function is created to easily connect the generated routes to the Ballast Navigation VM builder.
 */
public fun BallastViewModelConfiguration.Builder.withAppScreenRouter(
    deepLinkDestination: (() -> String?)? = null
): RouterBuilder<AppScreenRoute> {
    return withRouter(
        routingTable = RoutingTable.fromEnum(AppScreenRoute.entries),
        initialRoute = AppScreenRoute.Home,
        deepLinkUrl = deepLinkDestination,
    )
}

/**
 * This function generically converts the appScreen to its matched class. It is assumed that all route classes share
 * a common supertype, otherwise the cast will fail. This is only needed if you do not wish to create the `when` block
 * yourself.
 */
@Suppress("UNCHECKED_CAST")
public fun <T : Any> Destination.Match<AppScreenRoute>.matchRoute(appScreen: AppScreenRoute): T? {
    return when (appScreen) {
        AppScreenRoute.Home -> Home.match(this) as T
        AppScreenRoute.PostList -> PostList.match(this) as T
        AppScreenRoute.PostDetails -> PostDetails.match(this) as T
    }
}

// Home
// ---------------------------------------------------------------------------------------------------------------------

/**
 * For each class annotated with `@Route`, and extension function on its companion object (or itself if it is an
 * `object`) gives you the corresponding `Route` that was generated for it.
 */
val Home.route: AppScreenRoute
    get() = AppScreenRoute.Home

/**
 * For each class annotated with `@Route`, and extension function on its companion object (or itself if it is an
 * `object`) builds the generated URL for its corresponding generated route. If there are any path or URL params in
 * the route, those will be added as parameters to this function.
 */
fun Home.navigate(): String {
    return route
        .directions()
        .build()
}

/**
 * For each class annotated with `@Route`, and extension function on its companion object (or itself if it is an
 * `object`) allows you to convert a `Destination.Match` into a concrete instance of the annotated class. All path
 * and query params are extracted with type-safety.
 */
fun Home.match(match: Destination.Match<AppScreenRoute>): Home = with(match) {
    return@with Home
}

// PostList
// ---------------------------------------------------------------------------------------------------------------------

val PostList.Companion.route: AppScreenRoute
    get() = AppScreenRoute.PostList

fun PostList.Companion.navigate(
    sort: String?
): String {
    return route
        .directions()
        .let {
            if (sort != null) {
                it.queryParameter("sort", sort.toString())
            } else {
                it
            }
        }
        .build()
}

fun PostList.Companion.match(match: Destination.Match<AppScreenRoute>): PostList = with(match) {
    val sort by optionalStringQuery("sort")
    return@with PostList(sort)
}

// PostDetails
// ---------------------------------------------------------------------------------------------------------------------

val PostDetails.Companion.route: AppScreenRoute
    get() = AppScreenRoute.PostDetails

fun PostDetails.Companion.navigate(
    postId: Int
): String {
    return AppScreenRoute.PostDetails
        .directions()
        .let {
            it.pathParameter("postId", postId.toString())
        }
        .build()
}

fun PostDetails.Companion.match(match: Destination.Match<AppScreenRoute>): PostDetails =
    with(match) {
        val postId by intPath("postId")
        return@with PostDetails(postId)
    }
